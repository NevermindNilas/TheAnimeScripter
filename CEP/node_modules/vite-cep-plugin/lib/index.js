"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsxBin = exports.runAction = exports.jsxPonyfill = exports.jsxInclude = exports.cep = void 0;
const os = require("os");
const path = require("path");
const copy_node_1 = require("./copy-node");
const jsxbin = require("jsxbin");
const fs = require("fs-extra");
const prettifyXml = require("prettify-xml");
// import { requirejs } from "./lib/require-js";
const lib_1 = require("./lib/lib");
const zxp_1 = require("./lib/zxp");
const manifest_template_1 = require("./templates/manifest-template");
const debug_template_1 = require("./templates/debug-template");
const dev_html_template_1 = require("./templates/dev-html-template");
const node_built_ins_1 = require("./lib/node-built-ins");
const magic_string_1 = require("magic-string");
const zip_1 = require("./lib/zip");
const package_sync_1 = require("./lib/package-sync");
const homedir = os.homedir();
const tmpDir = path.join(__dirname, ".tmp");
fs.ensureDirSync(tmpDir);
const ccGlobalExtensionFolder = os.platform() == "win32"
    ? "C:/Program Files (x86)/Common Files/Adobe/CEP/extensions"
    : "/Library/Application Support/Adobe/CEP/extensions/";
const ccLocalExtensionFolder = os.platform() == "win32"
    ? path.join(homedir, "/AppData/Roaming/Adobe/CEP/extensions")
    : path.join(homedir, `/Library/Application Support/Adobe/CEP/extensions`);
const makeSymlink = (dist, dest) => {
    try {
        if (symlinkExists(dest)) {
            if (path.resolve(fs.readlinkSync(dest)) === path.resolve(dist)) {
                (0, lib_1.log)("symlink already exists", true);
                return "exists";
            }
            else {
                // incorrect link, remove and re-create
                fs.unlinkSync(dest);
            }
        }
        fs.mkdirSync(path.dirname(dest), { recursive: true });
        fs.symlinkSync(dist, dest, "junction");
        (0, lib_1.log)("symlink created", true);
        return "created";
    }
    catch (e) {
        console.log(e);
        (0, lib_1.log)("symlink failed. Try running 'sudo yarn symlink'", false);
        return "error";
    }
};
const removeSymlink = (dist, dest) => {
    try {
        if (symlinkExists(dest)) {
            fs.unlinkSync(dest);
            (0, lib_1.log)("symlink removed successfully", true);
            return "removed";
        }
        else {
            (0, lib_1.log)("no symlink exists", true);
            return "none";
        }
    }
    catch (e) {
        (0, lib_1.log)("symlink removal failed. Try removing with 'sudo yarn delsymlink'", false);
        return "error";
    }
};
const symlinkExists = (dir) => {
    let exists, readlink, lstat;
    // try {
    //   exists = fs.existsSync(dir);
    // } catch (e) {}
    // try {
    //   readlink = fs.readlinkSync(dir);
    // } catch (e) {}
    try {
        lstat = fs.lstatSync(dir);
        exists = true;
    }
    catch (e) {
        exists = false;
    }
    return exists;
};
const injectRequire = fs.readFileSync(path.join(__dirname, "./lib/require-js.js"), {
    encoding: "utf-8",
});
let foundPackages = [];
const cep = (opts) => {
    const { cepConfig, dir, isProduction, isPackage, isMetaPackage, isServe, debugReact, cepDist, zxpDir, zipDir, packages, } = opts;
    if (cepConfig && cepConfig.panels && isServe) {
        console.clear();
        console.log(`${lib_1.conColors.green}CEP Panels Served at:`);
        console.log("");
        cepConfig.panels.map((panel) => {
            const relativePath = panel.mainPath;
            const name = panel.name;
            console.log(`${lib_1.conColors.white}   > ${name}: ${lib_1.conColors.cyan}http://localhost:${cepConfig.servePort}/${name}/`);
        });
        (0, lib_1.resetLog)();
        console.log("");
    }
    return {
        name: "cep",
        transformIndexHtml(code, opts) {
            const browserRequireIgnore = {
                tag: "script",
                children: injectRequire,
            };
            if (opts && opts.bundle) {
                Object.keys(opts.bundle).filter((file) => {
                    if (path.extname(file) === ".css") {
                        let newCode = opts.bundle[file].source;
                        if (newCode) {
                            opts.bundle[file].source = (0, lib_1.fixAssetPathCSS)(newCode);
                        }
                        else {
                            console.log("missing code: ", file);
                        }
                    }
                });
            }
            // console.log("HTML Transform");
            const isDev = opts.server !== undefined;
            if (isDev) {
                const tags = [browserRequireIgnore];
                return tags;
            }
            let cssFileNameMatches = code.match(/(href=\".*.css\")/g);
            const cssFileNames = cssFileNameMatches &&
                Array.from(cssFileNameMatches).map((file) => file.replace('href="', "").replace('"', ""));
            const jsFileNameMatch = code.match(/(src=\".*.js\")/);
            const jsFileName = jsFileNameMatch &&
                //@ts-ignore
                jsFileNameMatch.pop().replace('src="', "").replace('"', "");
            // TODO: better require transformations
            //@ts-ignore
            const jsName = jsFileName.substr(1);
            let newCode = opts.bundle[jsName].code;
            const allRequires = newCode.match(/(require\(\"([A-z]|[0-9]|\.|\/|\-)*\"\)(\;|\,))/g);
            if (allRequires) {
                const requireNames = allRequires.map((req) => 
                //@ts-ignore
                req.match(/(["'])(?:(?=(\\?))\2.)*?\1/)[0].replace(/\"/g, ""));
                const copyModules = requireNames.filter((name) => !node_built_ins_1.nodeBuiltIns.includes(name) && ![".", "/", "\\"].includes(name[0]));
                foundPackages = foundPackages.concat(copyModules);
            }
            const matches = newCode.match(/(\=require\(\"\.([A-z]|[0-9]|\.|\/|\-)*\"\)(\;|\,))/g);
            matches === null || matches === void 0 ? void 0 : matches.map((match) => {
                const jsPath = match.match(/\".*\"/);
                //@ts-ignore
                const jsBasename = path.basename(jsPath[0]);
                if (jsPath) {
                    newCode = newCode.replace(match.substring(0, match.length - 1), `=typeof cep_node !== 'undefined'?cep_node.require(cep_node.global["__dir"+"name"] + "/assets/${jsBasename}):require("../assets/${jsBasename})`);
                }
            });
            newCode = newCode.replace(`"use strict"`, `"use strict"\rif (typeof exports === 'undefined') { var exports = {}; }`);
            opts.bundle[jsName].code = newCode;
            Object.keys(opts.bundle).map((key) => {
                if (path.extname(key) === ".js") {
                    let { code, source } = opts.bundle[key];
                    if (code && code.replace) {
                        opts.bundle[key].code = (0, lib_1.fixAssetPathJS)(code);
                    }
                    else if (source && source.replace) {
                        opts.bundle[key].source = (0, lib_1.fixAssetPathJS)(source);
                    }
                    else {
                        console.log("missing code and source: ", opts.bundle[key]);
                    }
                }
            });
            const tags = [
                browserRequireIgnore,
                {
                    tag: "script",
                    attrs: { src: `..${jsFileName}` },
                    injectTo: "body",
                },
            ];
            code = (0, lib_1.removeModuleTags)(code);
            code = (0, lib_1.fixAssetPathHTML)(code);
            if (debugReact) {
                tags.push({
                    tag: "script",
                    attrs: { src: "http://localhost:8097" },
                    injectTo: "body",
                });
            }
            return {
                tags,
                html: code,
            };
        },
        configResolved(config) {
            if (!isProduction) {
                console.clear();
                console.log(`${lib_1.conColors.green}CEP Panels Served at:`);
                console.log("");
                //@ts-ignore
                Object.keys(config.build.rollupOptions.input).map((key) => {
                    //@ts-ignore
                    const filePath = config.build.rollupOptions.input[key];
                    const relativePath = path.relative(config.root, filePath);
                    const destPath = path.resolve(config.build.outDir, relativePath);
                    const panelHtmlFile = {
                        type: "asset",
                        source: (0, dev_html_template_1.devHtmlTemplate)(Object.assign(Object.assign({}, cepConfig), { url: `http://localhost:${cepConfig.port}/${(0, lib_1.posix)(relativePath)}`, injectRequire })),
                        name: "CEP HTML Dev File",
                        fileName: "index.html",
                    };
                    fs.writeFileSync(destPath, panelHtmlFile.source);
                    console.log(`${lib_1.conColors.white}   > ${path.dirname(relativePath)}: ${lib_1.conColors.cyan}http://localhost:${cepConfig.port}/${(0, lib_1.posix)(path.dirname(relativePath))}/`);
                });
            }
        },
        writeBundle() {
            return __awaiter(this, void 0, void 0, function* () {
                // console.log(" BUILD END");
                const root = "./";
                const src = "./src";
                const dest = "dist/cep";
                const symlink = false;
                const allPackages = (0, copy_node_1.unique)(packages.concat(foundPackages));
                (0, copy_node_1.copyModules)({ packages: allPackages, src: root, dest, symlink });
                if (cepConfig.copyAssets) {
                    (0, copy_node_1.copyFiles)({
                        src: path.join(process.cwd(), src),
                        dest: path.join(process.cwd(), dest),
                        assets: cepConfig.copyAssets,
                    });
                }
                // console.log("FINISH");
                if (isPackage) {
                    const zxpPath = yield (0, zxp_1.signZXP)(cepConfig, path.join(dir, cepDist), zxpDir, tmpDir);
                    if (isMetaPackage) {
                        yield (0, zip_1.metaPackage)(cepConfig, zipDir, zxpPath, src, cepConfig.copyZipAssets);
                    }
                }
            });
        },
        generateBundle(output, bundle) {
            return __awaiter(this, void 0, void 0, function* () {
                console.log(`${lib_1.conColors.green}cep process: ${(isPackage && "zxp package") || (isProduction && "build") || "dev"}`);
                // Fill any empty panel fields with extension's defaults
                const fillPanelFields = (config) => {
                    let newConfig = Object.assign(Object.assign({}, config), { panels: config.panels.map((panel) => {
                            let newProps = Object.assign(Object.assign({}, config), panel);
                            return {
                                id: panel.id ? panel.id : `${config.id}.${panel.name}`,
                                name: newProps.name,
                                parameters: newProps.parameters,
                                autoVisible: newProps.autoVisible,
                                mainPath: newProps.mainPath,
                                type: newProps.type,
                                host: newProps.host,
                                panelDisplayName: newProps.panelDisplayName,
                                width: newProps.width,
                                height: newProps.height,
                                minWidth: newProps.minWidth,
                                minHeight: newProps.minHeight,
                                maxWidth: newProps.maxWidth,
                                maxHeight: newProps.maxHeight,
                                iconNormal: newProps.iconNormal,
                                iconDarkNormal: newProps.iconDarkNormal,
                                iconNormalRollOver: newProps.iconNormalRollOver,
                                iconDarkNormalRollOver: newProps.iconDarkNormalRollOver,
                                scriptPath: newProps.scriptPath,
                                startOnEvents: newProps.startOnEvents,
                            };
                        }) });
                    return newConfig;
                };
                const extendedConfig = fillPanelFields(cepConfig);
                const manifestFile = {
                    type: "asset",
                    source: prettifyXml((0, manifest_template_1.manifestTemplate)(extendedConfig), {
                        indent: 2,
                        newline: "\n",
                    }),
                    name: "CEP Manifest File",
                    fileName: path.join("CSXS", "manifest.xml"),
                };
                //@ts-ignore
                this.emitFile(manifestFile);
                (0, lib_1.log)("manifest created", true);
                // const menuFile = {
                //   type: "asset",
                //   source: menuHtmlTemplate({
                //     displayName: cepConfig.displayName,
                //     menu: cepConfig.panels.map((panel) => {
                //       return {
                //         name: panel.name,
                //         url: panel.mainPath,
                //       };
                //     }),
                //   }),
                //   name: "Menu File",
                //   fileName: path.join("index.html"),
                // };
                //@ts-ignore
                // this.emitFile(menuFile);
                // log("menu created", true);
                const debugFile = {
                    type: "asset",
                    source: prettifyXml((0, debug_template_1.debugTemplate)(extendedConfig)),
                    name: "CEP Debug File",
                    fileName: path.join(".debug"),
                };
                //@ts-ignore
                this.emitFile(debugFile);
                (0, lib_1.log)("debug file created", true);
                try {
                    const symlinkPath = cepConfig.symlink === "global"
                        ? ccGlobalExtensionFolder
                        : ccLocalExtensionFolder;
                    const res = makeSymlink(path.join(dir, cepDist), path.join(symlinkPath, cepConfig.id));
                }
                catch (e) {
                    console.warn(e);
                }
                console.log("");
            });
        },
    };
};
exports.cep = cep;
const jsxInclude = ({ iife, globalThis, }) => {
    const foundIncludes = [];
    return {
        name: "extendscript-include-resolver",
        generateBundle: (output, bundle) => {
            const esFile = Object.keys(bundle).pop();
            const core = [
                "// ----- EXTENDSCRIPT INCLUDES ------ //",
                ...foundIncludes,
                "// ---------------------------------- //",
                bundle[esFile].code,
            ];
            if (iife) {
                const banner = `(function (${globalThis}) {`;
                const footer = "})(this);";
                bundle[esFile].code = [banner, ...core, footer].join("\r");
            }
            else {
                bundle[esFile].code = core.join("\r");
            }
        },
        transform: (code, id) => {
            const s = new magic_string_1.default(code);
            // console.log("looking for JSXINCLUDE");
            const includeMatches = code.match(/^\/\/(\s|)\@include(.*)/gm);
            if (includeMatches) {
                // console.log("FOUND!", matches);
                includeMatches.map((match) => {
                    const innerMatches = match.match(/(?:'|").*(?:'|")/);
                    const firstMatch = innerMatches === null || innerMatches === void 0 ? void 0 : innerMatches.pop();
                    if (firstMatch) {
                        const relativeDir = firstMatch.replace(/(\"|\')/g, "");
                        const filePath = path.join(path.dirname(id), relativeDir);
                        let text = "";
                        if (fs.existsSync(filePath)) {
                            text = fs.readFileSync(filePath, { encoding: "utf-8" });
                            foundIncludes.push(text);
                        }
                        else {
                            console.warn(`WARNING: File cannot be found for include ${match}`);
                        }
                        // console.log("INDEX :: ", code.indexOf(match));
                        // console.log("CODE :: ", code);
                        s.overwrite(code.indexOf(match), code.indexOf(match) + match.length, "");
                    }
                });
            }
            const commentMatches = code.match(/\/\/(\s|)\@(.*)/gm);
            if (commentMatches) {
                let end = 0;
                commentMatches.map((comment) => {
                    const start = code.indexOf(comment, end);
                    end = start + comment.length;
                    s.overwrite(start, end, "");
                });
            }
            return {
                code: s.toString(),
                map: s.generateMap({
                    source: id,
                    file: `${id}.map`,
                    includeContent: true,
                }),
            };
        },
    };
};
exports.jsxInclude = jsxInclude;
const jsxPonyfill = (extraPonyfills) => {
    let usedPonyfills = new Set();
    let ponyfills = [
        {
            find: "Object.freeze",
            replace: "__objectFreeze",
            inject: `function __objectFreeze(obj) { return obj; }`,
        },
        {
            find: "Array.isArray",
            replace: "__isArray",
            inject: `function __isArray(arr) { try { return arr instanceof Array; } catch (e) { return false; } };`,
        },
    ];
    if (extraPonyfills) {
        ponyfills = [...ponyfills, ...extraPonyfills];
    }
    return {
        name: "extendscript-ponyfill-resolver",
        generateBundle: (output, bundle) => {
            const esFile = Object.keys(bundle).pop();
            let ponyfillStr = [
                `// ----- EXTENDSCRIPT PONYFILLS -----`,
                Array.from(usedPonyfills)
                    .map((p) => p.inject)
                    .join("\r"),
                "// ---------------------------------- //",
            ].join("\r");
            const core = [ponyfillStr, bundle[esFile].code];
            bundle[esFile].code = core.join("\r");
        },
        renderChunk: (code, chunk) => {
            const id = chunk.fileName;
            const s = new magic_string_1.default(code);
            // console.log("Ponyfill Time");
            ponyfills.map((pony) => {
                const regexp = new RegExp(pony.find, "g");
                const gen = code.matchAll(regexp);
                // console.log("GEN", gen);
                if (gen) {
                    const matches = [...gen];
                    // console.log("FOUND!", pony.find);
                    matches.map((match) => {
                        usedPonyfills.add(pony);
                        const index = match.index;
                        const length = match[0].length;
                        if (index) {
                            // console.log("REPLACING :: ", index, index + length);
                            s.overwrite(index, index + length, pony.replace
                            // text
                            );
                        }
                    });
                }
            });
            return {
                code: s.toString(),
                map: s.generateMap({
                    source: id,
                    file: `${id}.map`,
                    includeContent: true,
                }),
            };
        },
    };
};
exports.jsxPonyfill = jsxPonyfill;
const runAction = (opts, action) => {
    const { cepConfig, dir, isProduction, isPackage, isServe, debugReact, cepDist, zxpDir, packages, } = opts;
    const symlinkPath = cepConfig.symlink === "global"
        ? ccGlobalExtensionFolder
        : ccLocalExtensionFolder;
    const symlinkSrc = path.join(dir, cepDist);
    const symlinkDst = path.join(symlinkPath, cepConfig.id);
    if (action === "symlink") {
        makeSymlink(symlinkSrc, symlinkDst);
    }
    else if (action === "delsymlink") {
        removeSymlink(symlinkSrc, symlinkDst);
    }
    else if (action === "dependencyCheck") {
        console.log("Checking Dependencies");
        (0, package_sync_1.packageSync)();
    }
    else {
        console.warn(`Unknown Action: ${action}`);
    }
    (0, lib_1.resetLog)();
};
exports.runAction = runAction;
const jsxBin = (jsxBinMode) => {
    return {
        name: "extendscript-jsxbin",
        generateBundle: function (output, bundle) {
            return __awaiter(this, void 0, void 0, function* () {
                if (jsxBinMode === "copy" || jsxBinMode === "replace") {
                    const esFile = Object.keys(bundle).pop();
                    if (esFile) {
                        // console.log("GENERATE JSXBIN");
                        const srcFilePathTmp = path.join(tmpDir, esFile);
                        const esFileBin = esFile.replace("js", "jsxbin");
                        const dstFilePathTmp = path.join(tmpDir, esFileBin);
                        const tmpSrc = fs.writeFileSync(srcFilePathTmp, bundle[esFile].code, {
                            encoding: "utf-8",
                        });
                        yield jsxbin(srcFilePathTmp, dstFilePathTmp);
                        const output = fs.readFileSync(dstFilePathTmp, { encoding: "utf-8" });
                        const jsxBinFile = {
                            type: "asset",
                            source: output,
                            name: "JSXBIN",
                            fileName: esFileBin,
                        };
                        //@ts-ignore
                        this.emitFile(jsxBinFile);
                        console.log(`JSXBIN Created: ${esFileBin}`);
                        if (jsxBinMode === "replace") {
                            delete bundle[esFile];
                        }
                    }
                }
            });
        },
    };
};
exports.jsxBin = jsxBin;
